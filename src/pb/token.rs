// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenInfo {
    /// The symbol of the token.f
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    /// The full name of the token.
    #[prost(string, tag="2")]
    pub token_name: ::prost::alloc::string::String,
    /// The current supply of the token.
    #[prost(int64, tag="3")]
    pub supply: i64,
    /// The total supply of the token.
    #[prost(int64, tag="4")]
    pub total_supply: i64,
    /// The precision of the token.
    #[prost(int32, tag="5")]
    pub decimals: i32,
    /// The address that has permission to issue the token.
    #[prost(message, optional, tag="6")]
    pub issuer: ::core::option::Option<::aelf_types::Address>,
    /// A flag indicating if this token is burnable.
    #[prost(bool, tag="7")]
    pub is_burnable: bool,
    /// The chain id of the token.
    #[prost(int32, tag="8")]
    pub issue_chain_id: i32,
    /// The amount of issued tokens.
    #[prost(int64, tag="9")]
    pub issued: i64,
    /// The external information of the token.
    #[prost(message, optional, tag="10")]
    pub external_info: ::core::option::Option<ExternalInfo>,
    /// The address that owns the token.
    #[prost(message, optional, tag="11")]
    pub owner: ::core::option::Option<::aelf_types::Address>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalInfo {
    #[prost(map="string, string", tag="1")]
    pub value: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInput {
    /// The symbol of the token.
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    /// The full name of the token.
    #[prost(string, tag="2")]
    pub token_name: ::prost::alloc::string::String,
    /// The total supply of the token.
    #[prost(int64, tag="3")]
    pub total_supply: i64,
    /// The precision of the token
    #[prost(int32, tag="4")]
    pub decimals: i32,
    /// The address that has permission to issue the token.
    #[prost(message, optional, tag="5")]
    pub issuer: ::core::option::Option<::aelf_types::Address>,
    /// A flag indicating if this token is burnable.
    #[prost(bool, tag="6")]
    pub is_burnable: bool,
    /// A whitelist address list used to lock tokens.
    #[prost(message, repeated, tag="7")]
    pub lock_white_list: ::prost::alloc::vec::Vec<::aelf_types::Address>,
    /// The chain id of the token.
    #[prost(int32, tag="8")]
    pub issue_chain_id: i32,
    /// The external information of the token.
    #[prost(message, optional, tag="9")]
    pub external_info: ::core::option::Option<ExternalInfo>,
    /// The address that owns the token.
    #[prost(message, optional, tag="10")]
    pub owner: ::core::option::Option<::aelf_types::Address>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetPrimaryTokenSymbolInput {
    /// The symbol of the token.
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IssueInput {
    /// The token symbol to issue.
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    /// The token amount to issue.
    #[prost(int64, tag="2")]
    pub amount: i64,
    /// The memo.
    #[prost(string, tag="3")]
    pub memo: ::prost::alloc::string::String,
    /// The target address to issue.
    #[prost(message, optional, tag="4")]
    pub to: ::core::option::Option<::aelf_types::Address>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferInput {
    /// The receiver of the token.
    #[prost(message, optional, tag="1")]
    pub to: ::core::option::Option<::aelf_types::Address>,
    /// The token symbol to transfer.
    #[prost(string, tag="2")]
    pub symbol: ::prost::alloc::string::String,
    /// The amount to to transfer.
    #[prost(int64, tag="3")]
    pub amount: i64,
    /// The memo.
    #[prost(string, tag="4")]
    pub memo: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LockInput {
    /// The one want to lock his token.
    #[prost(message, optional, tag="1")]
    pub address: ::core::option::Option<::aelf_types::Address>,
    /// Id of the lock.
    #[prost(message, optional, tag="2")]
    pub lock_id: ::core::option::Option<::aelf_types::Hash>,
    /// The symbol of the token to lock.
    #[prost(string, tag="3")]
    pub symbol: ::prost::alloc::string::String,
    /// a memo.
    #[prost(string, tag="4")]
    pub usage: ::prost::alloc::string::String,
    /// The amount of tokens to lock.
    #[prost(int64, tag="5")]
    pub amount: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnlockInput {
    /// The one want to un-lock his token.
    #[prost(message, optional, tag="1")]
    pub address: ::core::option::Option<::aelf_types::Address>,
    /// Id of the lock.
    #[prost(message, optional, tag="2")]
    pub lock_id: ::core::option::Option<::aelf_types::Hash>,
    /// The symbol of the token to un-lock.
    #[prost(string, tag="3")]
    pub symbol: ::prost::alloc::string::String,
    /// a memo.
    #[prost(string, tag="4")]
    pub usage: ::prost::alloc::string::String,
    /// The amount of tokens to un-lock.
    #[prost(int64, tag="5")]
    pub amount: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferFromInput {
    /// The source address of the token.
    #[prost(message, optional, tag="1")]
    pub from: ::core::option::Option<::aelf_types::Address>,
    /// The destination address of the token.
    #[prost(message, optional, tag="2")]
    pub to: ::core::option::Option<::aelf_types::Address>,
    /// The symbol of the token to transfer.
    #[prost(string, tag="3")]
    pub symbol: ::prost::alloc::string::String,
    /// The amount to transfer.
    #[prost(int64, tag="4")]
    pub amount: i64,
    /// The memo.
    #[prost(string, tag="5")]
    pub memo: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApproveInput {
    /// The address that allowance will be increased.
    #[prost(message, optional, tag="1")]
    pub spender: ::core::option::Option<::aelf_types::Address>,
    /// The symbol of token to approve.
    #[prost(string, tag="2")]
    pub symbol: ::prost::alloc::string::String,
    /// The amount of token to approve.
    #[prost(int64, tag="3")]
    pub amount: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchApproveInput {
    #[prost(message, repeated, tag="1")]
    pub value: ::prost::alloc::vec::Vec<ApproveInput>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnApproveInput {
    /// The address that allowance will be decreased.
    #[prost(message, optional, tag="1")]
    pub spender: ::core::option::Option<::aelf_types::Address>,
    /// The symbol of token to un-approve.
    #[prost(string, tag="2")]
    pub symbol: ::prost::alloc::string::String,
    /// The amount of token to un-approve.
    #[prost(int64, tag="3")]
    pub amount: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BurnInput {
    /// The symbol of token to burn.
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    /// The amount of token to burn.
    #[prost(int64, tag="2")]
    pub amount: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChargeResourceTokenInput {
    /// Collection of charge resource token, Symbol->Amount.
    #[prost(map="string, int64", tag="1")]
    pub cost_dic: ::std::collections::HashMap<::prost::alloc::string::String, i64>,
    /// The sender of the transaction.
    #[prost(message, optional, tag="2")]
    pub caller: ::core::option::Option<::aelf_types::Address>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionFeeBill {
    /// The transaction fee dictionary, Symbol->fee.
    #[prost(map="string, int64", tag="1")]
    pub fees_map: ::std::collections::HashMap<::prost::alloc::string::String, i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionFreeFeeAllowanceBill {
    /// The transaction free fee allowance dictionary, Symbol->fee.
    #[prost(map="string, int64", tag="1")]
    pub free_fee_allowances_map: ::std::collections::HashMap<::prost::alloc::string::String, i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckThresholdInput {
    /// The sender of the transaction.
    #[prost(message, optional, tag="1")]
    pub sender: ::core::option::Option<::aelf_types::Address>,
    /// The threshold to set, Symbol->Threshold.
    #[prost(map="string, int64", tag="2")]
    pub symbol_to_threshold: ::std::collections::HashMap<::prost::alloc::string::String, i64>,
    /// Whether to check the allowance.
    #[prost(bool, tag="3")]
    pub is_check_allowance: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTokenInfoInput {
    /// The symbol of token.
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBalanceInput {
    /// The symbol of token.
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    /// The target address of the query.
    #[prost(message, optional, tag="2")]
    pub owner: ::core::option::Option<::aelf_types::Address>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBalanceOutput {
    /// The symbol of token.
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    /// The target address of the query.
    #[prost(message, optional, tag="2")]
    pub owner: ::core::option::Option<::aelf_types::Address>,
    /// The balance of the owner.
    #[prost(int64, tag="3")]
    pub balance: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllowanceInput {
    /// The symbol of token.
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    /// The address of the token owner.
    #[prost(message, optional, tag="2")]
    pub owner: ::core::option::Option<::aelf_types::Address>,
    /// The address of the spender.
    #[prost(message, optional, tag="3")]
    pub spender: ::core::option::Option<::aelf_types::Address>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllowanceOutput {
    /// The symbol of token.
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    /// The address of the token owner.
    #[prost(message, optional, tag="2")]
    pub owner: ::core::option::Option<::aelf_types::Address>,
    /// The address of the spender.
    #[prost(message, optional, tag="3")]
    pub spender: ::core::option::Option<::aelf_types::Address>,
    /// The amount of allowance.
    #[prost(int64, tag="4")]
    pub allowance: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrossChainTransferInput {
    /// The receiver of transfer.
    #[prost(message, optional, tag="1")]
    pub to: ::core::option::Option<::aelf_types::Address>,
    /// The symbol of token.
    #[prost(string, tag="2")]
    pub symbol: ::prost::alloc::string::String,
    /// The amount of token to transfer.
    #[prost(int64, tag="3")]
    pub amount: i64,
    /// The memo.
    #[prost(string, tag="4")]
    pub memo: ::prost::alloc::string::String,
    /// The destination chain id.
    #[prost(int32, tag="5")]
    pub to_chain_id: i32,
    /// The chain id of the token.
    #[prost(int32, tag="6")]
    pub issue_chain_id: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrossChainReceiveTokenInput {
    /// The source chain id.
    #[prost(int32, tag="1")]
    pub from_chain_id: i32,
    /// The height of the transfer transaction.
    #[prost(int64, tag="2")]
    pub parent_chain_height: i64,
    /// The raw bytes of the transfer transaction.
    #[prost(bytes="vec", tag="3")]
    pub transfer_transaction_bytes: ::prost::alloc::vec::Vec<u8>,
    /// The merkle path created from the transfer transaction.
    #[prost(message, optional, tag="4")]
    pub merkle_path: ::core::option::Option<::aelf_types::MerklePath>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IsInWhiteListInput {
    /// The symbol of token.
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    /// The address to check.
    #[prost(message, optional, tag="2")]
    pub address: ::core::option::Option<::aelf_types::Address>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SymbolToPayTxSizeFee {
    /// The symbol of token.
    #[prost(string, tag="1")]
    pub token_symbol: ::prost::alloc::string::String,
    /// The charge weight of primary token.
    #[prost(int32, tag="2")]
    pub base_token_weight: i32,
    /// The new added token charge weight. For example, the charge weight of primary Token is set to 1.
    /// The newly added token charge weight is set to 10. If the transaction requires 1 unit of primary token,
    /// the user can also pay for 10 newly added tokens.
    #[prost(int32, tag="3")]
    pub added_token_weight: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SymbolListToPayTxSizeFee {
    /// Transaction fee token information.
    #[prost(message, repeated, tag="1")]
    pub symbols_to_pay_tx_size_fee: ::prost::alloc::vec::Vec<SymbolToPayTxSizeFee>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChargeTransactionFeesInput {
    /// The method name of transaction.
    #[prost(string, tag="1")]
    pub method_name: ::prost::alloc::string::String,
    /// The contract address of transaction.
    #[prost(message, optional, tag="2")]
    pub contract_address: ::core::option::Option<::aelf_types::Address>,
    /// The amount of transaction size fee.
    #[prost(int64, tag="3")]
    pub transaction_size_fee: i64,
    /// Transaction fee token information.
    #[prost(message, repeated, tag="4")]
    pub symbols_to_pay_tx_size_fee: ::prost::alloc::vec::Vec<SymbolToPayTxSizeFee>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChargeTransactionFeesOutput {
    /// Whether the charge was successful.
    #[prost(bool, tag="1")]
    pub success: bool,
    /// The charging information.
    #[prost(string, tag="2")]
    pub charging_information: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallbackInfo {
    #[prost(message, optional, tag="1")]
    pub contract_address: ::core::option::Option<::aelf_types::Address>,
    #[prost(string, tag="2")]
    pub method_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtraTokenListModified {
    /// Transaction fee token information.
    #[prost(message, optional, tag="1")]
    pub symbol_list_to_pay_tx_size_fee: ::core::option::Option<SymbolListToPayTxSizeFee>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLockedAmountInput {
    /// The address of the lock.
    #[prost(message, optional, tag="1")]
    pub address: ::core::option::Option<::aelf_types::Address>,
    /// The token symbol.
    #[prost(string, tag="2")]
    pub symbol: ::prost::alloc::string::String,
    /// The id of the lock.
    #[prost(message, optional, tag="3")]
    pub lock_id: ::core::option::Option<::aelf_types::Hash>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLockedAmountOutput {
    /// The address of the lock.
    #[prost(message, optional, tag="1")]
    pub address: ::core::option::Option<::aelf_types::Address>,
    /// The token symbol.
    #[prost(string, tag="2")]
    pub symbol: ::prost::alloc::string::String,
    /// The id of the lock.
    #[prost(message, optional, tag="3")]
    pub lock_id: ::core::option::Option<::aelf_types::Hash>,
    /// The locked amount.
    #[prost(int64, tag="4")]
    pub amount: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenInfoList {
    /// List of token information.
    #[prost(message, repeated, tag="1")]
    pub value: ::prost::alloc::vec::Vec<TokenInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetCrossChainTransferTokenContractAddressInput {
    /// The chain id.
    #[prost(int32, tag="1")]
    pub chain_id: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrossChainCreateTokenInput {
    /// The chain id of the chain on which the token was created.
    #[prost(int32, tag="1")]
    pub from_chain_id: i32,
    /// The height of the transaction that created the token.
    #[prost(int64, tag="2")]
    pub parent_chain_height: i64,
    /// The transaction that created the token.
    #[prost(bytes="vec", tag="3")]
    pub transaction_bytes: ::prost::alloc::vec::Vec<u8>,
    /// The merkle path created from the transaction that created the transaction.
    #[prost(message, optional, tag="4")]
    pub merkle_path: ::core::option::Option<::aelf_types::MerklePath>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitializeFromParentChainInput {
    /// The amount of resource.
    #[prost(map="string, int32", tag="1")]
    pub resource_amount: ::std::collections::HashMap<::prost::alloc::string::String, i32>,
    /// The token contract addresses.
    #[prost(map="int32, message", tag="2")]
    pub registered_other_token_contract_addresses: ::std::collections::HashMap<i32, ::aelf_types::Address>,
    /// The creator the side chain.
    #[prost(message, optional, tag="3")]
    pub creator: ::core::option::Option<::aelf_types::Address>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCoefficientsInput {
    /// The specify pieces gonna update.
    #[prost(int32, repeated, tag="1")]
    pub piece_numbers: ::prost::alloc::vec::Vec<i32>,
    /// Coefficients of one single type.
    #[prost(message, optional, tag="2")]
    pub coefficients: ::core::option::Option<CalculateFeeCoefficients>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculateFeePieceCoefficients {
    /// Coefficients of one single piece.
    /// The first char is its type: liner / power.
    /// The second char is its piece upper bound.
    #[prost(int32, repeated, tag="1")]
    pub value: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculateFeeCoefficients {
    /// The resource fee type, like READ, WRITE, etc.
    #[prost(int32, tag="1")]
    pub fee_token_type: i32,
    /// Coefficients of one single piece.
    #[prost(message, repeated, tag="2")]
    pub piece_coefficients_list: ::prost::alloc::vec::Vec<CalculateFeePieceCoefficients>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllCalculateFeeCoefficients {
    /// The coefficients of fee Calculation.
    #[prost(message, repeated, tag="1")]
    pub value: ::prost::alloc::vec::Vec<CalculateFeeCoefficients>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TotalTransactionFeesMap {
    /// Token dictionary that charge transaction fee, Symbol->Amount.
    #[prost(map="string, int64", tag="1")]
    pub value: ::std::collections::HashMap<::prost::alloc::string::String, i64>,
    /// The hash of the block processing the transaction.
    #[prost(message, optional, tag="2")]
    pub block_hash: ::core::option::Option<::aelf_types::Hash>,
    /// The height of the block processing the transaction.
    #[prost(int64, tag="3")]
    pub block_height: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TotalResourceTokensMaps {
    /// Resource tokens to charge.
    #[prost(message, repeated, tag="1")]
    pub value: ::prost::alloc::vec::Vec<ContractTotalResourceTokens>,
    /// The hash of the block processing the transaction.
    #[prost(message, optional, tag="2")]
    pub block_hash: ::core::option::Option<::aelf_types::Hash>,
    /// The height of the block processing the transaction.
    #[prost(int64, tag="3")]
    pub block_height: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContractTotalResourceTokens {
    /// The contract address.
    #[prost(message, optional, tag="1")]
    pub contract_address: ::core::option::Option<::aelf_types::Address>,
    /// Resource tokens to charge.
    #[prost(message, optional, tag="2")]
    pub tokens_map: ::core::option::Option<TotalResourceTokensMap>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TotalResourceTokensMap {
    /// Resource token dictionary, Symbol->Amount.
    #[prost(map="string, int64", tag="1")]
    pub value: ::std::collections::HashMap<::prost::alloc::string::String, i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringList {
    #[prost(string, repeated, tag="1")]
    pub value: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionFeeDelegations {
    /// delegation, symbols and its' amount
    #[prost(map="string, int64", tag="1")]
    pub delegations: ::std::collections::HashMap<::prost::alloc::string::String, i64>,
    /// height when added
    #[prost(int64, tag="2")]
    pub block_height: i64,
    /// Whether to pay transaction fee continuously
    #[prost(bool, tag="3")]
    pub is_unlimited_delegate: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionFeeDelegatees {
    #[prost(map="string, message", tag="1")]
    pub delegatees: ::std::collections::HashMap<::prost::alloc::string::String, TransactionFeeDelegations>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTransactionFeeDelegationsInput {
    /// the delegator address
    #[prost(message, optional, tag="1")]
    pub delegator_address: ::core::option::Option<::aelf_types::Address>,
    /// delegation, symbols and its' amount
    #[prost(map="string, int64", tag="2")]
    pub delegations: ::std::collections::HashMap<::prost::alloc::string::String, i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetTransactionFeeDelegationsOutput {
    #[prost(bool, tag="1")]
    pub success: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveTransactionFeeDelegatorInput {
    /// the delegator address
    #[prost(message, optional, tag="1")]
    pub delegator_address: ::core::option::Option<::aelf_types::Address>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveTransactionFeeDelegateeInput {
    /// the delegatee address
    #[prost(message, optional, tag="1")]
    pub delegatee_address: ::core::option::Option<::aelf_types::Address>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionFeeDelegationsOfADelegateeInput {
    #[prost(message, optional, tag="1")]
    pub delegatee_address: ::core::option::Option<::aelf_types::Address>,
    #[prost(message, optional, tag="2")]
    pub delegator_address: ::core::option::Option<::aelf_types::Address>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionFeeDelegateesInput {
    #[prost(message, optional, tag="1")]
    pub delegator_address: ::core::option::Option<::aelf_types::Address>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionFeeDelegateesOutput {
    #[prost(message, repeated, tag="1")]
    pub delegatee_addresses: ::prost::alloc::vec::Vec<::aelf_types::Address>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetSymbolAliasInput {
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub alias: ::prost::alloc::string::String,
}
// Events

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transferred {
    /// The source address of the transferred token.
    #[prost(message, optional, tag="1")]
    pub from: ::core::option::Option<::aelf_types::Address>,
    /// The destination address of the transferred token.
    #[prost(message, optional, tag="2")]
    pub to: ::core::option::Option<::aelf_types::Address>,
    /// The symbol of the transferred token.
    #[prost(string, tag="3")]
    pub symbol: ::prost::alloc::string::String,
    /// The amount of the transferred token.
    #[prost(int64, tag="4")]
    pub amount: i64,
    /// The memo.
    #[prost(string, tag="5")]
    pub memo: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Approved {
    /// The address of the token owner.
    #[prost(message, optional, tag="1")]
    pub owner: ::core::option::Option<::aelf_types::Address>,
    /// The address that allowance be increased.
    #[prost(message, optional, tag="2")]
    pub spender: ::core::option::Option<::aelf_types::Address>,
    /// The symbol of approved token.
    #[prost(string, tag="3")]
    pub symbol: ::prost::alloc::string::String,
    /// The amount of approved token.
    #[prost(int64, tag="4")]
    pub amount: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnApproved {
    /// The address of the token owner.
    #[prost(message, optional, tag="1")]
    pub owner: ::core::option::Option<::aelf_types::Address>,
    /// The address that allowance be decreased.
    #[prost(message, optional, tag="2")]
    pub spender: ::core::option::Option<::aelf_types::Address>,
    /// The symbol of un-approved token.
    #[prost(string, tag="3")]
    pub symbol: ::prost::alloc::string::String,
    /// The amount of un-approved token.
    #[prost(int64, tag="4")]
    pub amount: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Burned {
    /// The address who wants to burn token.
    #[prost(message, optional, tag="1")]
    pub burner: ::core::option::Option<::aelf_types::Address>,
    /// The symbol of burned token.
    #[prost(string, tag="2")]
    pub symbol: ::prost::alloc::string::String,
    /// The amount of burned token.
    #[prost(int64, tag="3")]
    pub amount: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChainPrimaryTokenSymbolSet {
    /// The symbol of token.
    #[prost(string, tag="1")]
    pub token_symbol: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculateFeeAlgorithmUpdated {
    /// All calculate fee coefficients after modification.
    #[prost(message, optional, tag="1")]
    pub all_type_fee_coefficients: ::core::option::Option<AllCalculateFeeCoefficients>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RentalCharged {
    /// The symbol of rental fee charged.
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    /// The amount of rental fee charged.
    #[prost(int64, tag="2")]
    pub amount: i64,
    /// The payer of rental fee.
    #[prost(message, optional, tag="3")]
    pub payer: ::core::option::Option<::aelf_types::Address>,
    /// The receiver of rental fee.
    #[prost(message, optional, tag="4")]
    pub receiver: ::core::option::Option<::aelf_types::Address>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RentalAccountBalanceInsufficient {
    /// The symbol of insufficient rental account balance.
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    /// The balance of the account.
    #[prost(int64, tag="2")]
    pub amount: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenCreated {
    /// The symbol of the token.
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    /// The full name of the token.
    #[prost(string, tag="2")]
    pub token_name: ::prost::alloc::string::String,
    /// The total supply of the token.
    #[prost(int64, tag="3")]
    pub total_supply: i64,
    /// The precision of the token.
    #[prost(int32, tag="4")]
    pub decimals: i32,
    /// The address that has permission to issue the token.
    #[prost(message, optional, tag="5")]
    pub issuer: ::core::option::Option<::aelf_types::Address>,
    /// A flag indicating if this token is burnable.
    #[prost(bool, tag="6")]
    pub is_burnable: bool,
    /// The chain id of the token.
    #[prost(int32, tag="7")]
    pub issue_chain_id: i32,
    /// The external information of the token.
    #[prost(message, optional, tag="8")]
    pub external_info: ::core::option::Option<ExternalInfo>,
    /// The address that owns the token.
    #[prost(message, optional, tag="9")]
    pub owner: ::core::option::Option<::aelf_types::Address>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Issued {
    /// The symbol of issued token.
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    /// The amount of issued token.
    #[prost(int64, tag="2")]
    pub amount: i64,
    /// The memo.
    #[prost(string, tag="3")]
    pub memo: ::prost::alloc::string::String,
    /// The issued target address.
    #[prost(message, optional, tag="4")]
    pub to: ::core::option::Option<::aelf_types::Address>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrossChainTransferred {
    /// The source address of the transferred token.
    #[prost(message, optional, tag="1")]
    pub from: ::core::option::Option<::aelf_types::Address>,
    /// The destination address of the transferred token.
    #[prost(message, optional, tag="2")]
    pub to: ::core::option::Option<::aelf_types::Address>,
    /// The symbol of the transferred token.
    #[prost(string, tag="3")]
    pub symbol: ::prost::alloc::string::String,
    /// The amount of the transferred token.
    #[prost(int64, tag="4")]
    pub amount: i64,
    /// The memo.
    #[prost(string, tag="5")]
    pub memo: ::prost::alloc::string::String,
    /// The destination chain id.
    #[prost(int32, tag="6")]
    pub to_chain_id: i32,
    /// The chain id of the token.
    #[prost(int32, tag="7")]
    pub issue_chain_id: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrossChainReceived {
    /// The source address of the transferred token.
    #[prost(message, optional, tag="1")]
    pub from: ::core::option::Option<::aelf_types::Address>,
    /// The destination address of the transferred token.
    #[prost(message, optional, tag="2")]
    pub to: ::core::option::Option<::aelf_types::Address>,
    /// The symbol of the received token.
    #[prost(string, tag="3")]
    pub symbol: ::prost::alloc::string::String,
    /// The amount of the received token.
    #[prost(int64, tag="4")]
    pub amount: i64,
    /// The memo.
    #[prost(string, tag="5")]
    pub memo: ::prost::alloc::string::String,
    /// The destination chain id.
    #[prost(int32, tag="6")]
    pub from_chain_id: i32,
    /// The chain id of the token.
    #[prost(int32, tag="7")]
    pub issue_chain_id: i32,
    /// The parent chain height of the transfer transaction.
    #[prost(int64, tag="8")]
    pub parent_chain_height: i64,
    /// The id of transfer transaction.
    #[prost(message, optional, tag="9")]
    pub transfer_transaction_id: ::core::option::Option<::aelf_types::Hash>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionFeeDelegationAdded {
    #[prost(message, optional, tag="1")]
    pub delegator: ::core::option::Option<::aelf_types::Address>,
    #[prost(message, optional, tag="2")]
    pub delegatee: ::core::option::Option<::aelf_types::Address>,
    #[prost(message, optional, tag="3")]
    pub caller: ::core::option::Option<::aelf_types::Address>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionFeeDelegationCancelled {
    #[prost(message, optional, tag="1")]
    pub delegator: ::core::option::Option<::aelf_types::Address>,
    #[prost(message, optional, tag="2")]
    pub delegatee: ::core::option::Option<::aelf_types::Address>,
    #[prost(message, optional, tag="3")]
    pub caller: ::core::option::Option<::aelf_types::Address>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SymbolAliasAdded {
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub alias: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SymbolAliasDeleted {
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub alias: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FeeTypeEnum {
    Read = 0,
    Storage = 1,
    Write = 2,
    Traffic = 3,
    Tx = 4,
}
impl FeeTypeEnum {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            FeeTypeEnum::Read => "READ",
            FeeTypeEnum::Storage => "STORAGE",
            FeeTypeEnum::Write => "WRITE",
            FeeTypeEnum::Traffic => "TRAFFIC",
            FeeTypeEnum::Tx => "TX",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "READ" => Some(Self::Read),
            "STORAGE" => Some(Self::Storage),
            "WRITE" => Some(Self::Write),
            "TRAFFIC" => Some(Self::Traffic),
            "TX" => Some(Self::Tx),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
